// Week 1-2: Arrays and Strings
// Focus on patterns like sliding window, two pointers, and prefix sums.
// Topics:
// Array basics: Traversal, insertion, deletion.
// Subarray problems: Sum, product, and sliding window techniques.
// String manipulations: Palindromes, substrings, and pattern matching.
// Suggested LeetCode Problems:
// Easy:
// Two Sum
// Best Time to Buy and Sell Stock
// Longest Common Prefix
// Medium:
// 3Sum
// Container With Most Water
// Longest Substring Without Repeating Characters
// Hard:
// Sliding Window Maximum
// Week 3-4: Hashing and Two Pointers
// Learn efficient ways to store and retrieve data using hashmaps and hashsets.
// Topics:
// Frequency counting with HashMap/HashSet.
// Using hashmaps for two-sum, subarray problems, and detecting duplicates.
// Two-pointer techniques for sorting, searching, and merging arrays.
// Suggested LeetCode Problems:
// Easy:
// Valid Anagram
// Intersection of Two Arrays
// Medium:
// Group Anagrams
// Longest Palindrome by Concatenating Two Letter Words
// 4Sum
// Hard:
// Substring with Concatenation of All Words
// Week 5-6: Linked List
// Understand the mechanics of singly and doubly linked lists.
// Topics:
// Operations: Reverse, merge, and detect cycles.
// Adding/removing nodes at specific positions.
// Solving problems with recursion in linked lists.
// Suggested LeetCode Problems:
// Easy:
// Reverse Linked List
// Merge Two Sorted Lists
// Medium:
// Linked List Cycle
// Add Two Numbers
// Hard:
// Merge k Sorted Lists
// Reverse Nodes in k-Group
// Week 7-8: Stack and Queue
// Learn to use these data structures for solving interval and bracket problems.
// Topics:
// Balanced parentheses using stacks.
// Sliding window maximum using deque.
// Implement BFS with queues.
// Suggested LeetCode Problems:
// Easy:
// Valid Parentheses
// Implement Queue Using Stacks
// Medium:
// Min Stack
// Daily Temperatures
// Hard:
// Largest Rectangle in Histogram
// Sliding Window Maximum
// Week 9-10: Trees
// Master tree traversal techniques and understand binary search trees.
// Topics:
// Traversals: Inorder, Preorder, Postorder.
// Depth, height, and diameter of a tree.
// Lowest Common Ancestor (LCA).
// Suggested LeetCode Problems:
// Easy:
// Maximum Depth of Binary Tree
// Symmetric Tree
// Medium:
// Binary Tree Inorder Traversal
// Path Sum II
// Hard:
// Serialize and Deserialize Binary Tree
// Binary Tree Maximum Path Sum
// Week 11-12: Graphs
// Focus on BFS, DFS, and graph algorithms like Dijkstra’s and Kruskal’s.
// Topics:
// Graph representations (adjacency matrix, list).
// BFS and DFS traversal.
// Detecting cycles in a graph.
// Suggested LeetCode Problems:
// Easy:
// Find the Town Judge
// Medium:
// Course Schedule
// Word Ladder
// Hard:
// Minimum Spanning Tree (Prim's/Kruskal's)
// Shortest Path in a Grid with Obstacles
// Week 13-16: Advanced Algorithms
// Combine learned techniques and solve complex problems.
// Topics:
// Dynamic Programming: Fibonacci, Knapsack, and Subsequence problems.
// Backtracking: N-Queens, Permutations.
// Greedy Algorithms: Interval scheduling, activity selection.
// Plan Highlights:
// Daily Goals:

// Solve 3 problems/day: 1 Easy, 1 Medium, 1 Hard.
// Alternate between different topics each week.
// Review:

// Revisit problems you couldn’t solve or required help.
// Write down optimized solutions and compare them.
// Mock Contests:

// Join weekly LeetCode contests to simulate a real-time environment.
// Track Progress:

// Keep a log of problems solved and categorize them by topic and difficulty.